import numpy as np 

def needleman_wunsch(protein1, protein2, scoring_scheme):
    """
    Compute the scoring matrix for the Needleman-Wunsch algorithm.

    Parameters:
    protein1 (str): The first protein sequence.
    protein2 (str): The second protein sequence.
    scoring_scheme (dict): A dictionary containing the scoring parameters:
        - match_score: Score for a match.
        - mismatch_penalty: Penalty for a mismatch.
        - gap_penalty: Penalty for a gap.

    Returns:
    np.ndarray: The filled scoring matrix.
    """
    match_score = scoring_scheme['match_score']
    mismatch_penalty = scoring_scheme['mismatch_penalty']
    gap_penalty = scoring_scheme['gap_penalty']
    
    n, m = len(protein1), len(protein2)
    scores = np.zeros((n + 1, m + 1))
    
    # Initialize the first row and column with gap penalties
    for i in range(1, n + 1):
        scores[i, 0] = gap_penalty * i
    for j in range(1, m + 1):
        scores[0, j] = gap_penalty * j
    
    # Fill the scoring matrix
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            match = scores[i - 1, j - 1] + (match_score if protein1[i - 1] == protein2[j - 1] else mismatch_penalty)
            delete = scores[i - 1, j] + gap_penalty
            insert = scores[i, j - 1] + gap_penalty
            scores[i, j] = max(match, delete, insert)
    
    return scores

def find_all_paths(scores, protein1, protein2, scoring_scheme):
    """
    Trace all optimal alignment paths from the scoring matrix.

    Parameters:
    scores (np.ndarray): The scoring matrix generated by the Needleman-Wunsch algorithm.
    protein1 (str): The first protein sequence.
    protein2 (str): The second protein sequence.
    scoring_scheme (dict): The scoring parameters used for alignment.

    Returns:
    list: A list of all optimal alignment paths.
    """
    match_score = scoring_scheme['match_score']
    mismatch_penalty = scoring_scheme['mismatch_penalty']
    gap_penalty = scoring_scheme['gap_penalty']
    
    all_paths = []

    def traceback(i, j, current_path):
        if i == 0 and j == 0:
            all_paths.append(current_path)
            return

        # Move diagonally if characters match or mismatch penalty applies
        if i > 0 and j > 0 and (scores[i, j] == scores[i - 1, j - 1] +
                                 (match_score if protein1[i - 1] == protein2[j - 1] else mismatch_penalty)):
            traceback(i - 1, j - 1, current_path + [(i - 1, j - 1)])

        # Move up (deletion)
        if i > 0 and scores[i, j] == scores[i - 1, j] + gap_penalty:
            traceback(i - 1, j, current_path + [(i - 1, j)])

        # Move left (insertion)
        if j > 0 and scores[i, j] == scores[i, j - 1] + gap_penalty:
            traceback(i, j - 1, current_path + [(i, j - 1)])

    traceback(len(protein1), len(protein2), [(len(protein1), len(protein2))])
    return all_paths
