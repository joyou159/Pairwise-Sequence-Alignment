import numpy as np

def needleman_wunsch(seq1, seq2, scoring_scheme):
    """
    Compute the scoring matrix for the Needleman-Wunsch algorithm.

    Parameters:
    seq1 (str or list): The first sequence.
    seq2 (str or list): The second sequence.
    scoring_scheme (dict): A dictionary containing the scoring parameters:
        - match_score: Score for a match.
        - mismatch_penalty: Penalty for a mismatch.
        - gap_penalty: Penalty for a gap.

    Returns:
    np.ndarray: The filled scoring matrix.
    """
    match_score = scoring_scheme['match_score']
    mismatch_penalty = scoring_scheme['mismatch_penalty']
    gap_penalty = scoring_scheme['gap_penalty']
    
    n, m = len(seq1), len(seq2)
    scores = np.zeros((n + 1, m + 1))
    
    # Initialize the first row and column with gap penalties
    for i in range(1, n + 1):
        scores[i, 0] = gap_penalty * i
    for j in range(1, m + 1):
        scores[0, j] = gap_penalty * j
    
    # Fill the scoring matrix
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            match = scores[i - 1, j - 1] + (match_score if seq1[i - 1] == seq2[j - 1] else mismatch_penalty)
            delete = scores[i - 1, j] + gap_penalty
            insert = scores[i, j - 1] + gap_penalty
            scores[i, j] = max(match, delete, insert)
    
    return scores

def find_all_paths(scores, seq1, seq2, scoring_scheme):
    """
    Trace all optimal alignment paths from the scoring matrix.

    Parameters:
    scores (np.ndarray): The scoring matrix generated by the Needleman-Wunsch algorithm.
    seq1 (str or list): The first sequence.
    seq2 (str or list): The second sequence.
    scoring_scheme (dict): The scoring parameters used for alignment.

    Returns:
    list: A list of all optimal alignment paths.
    """
    match_score = scoring_scheme['match_score']
    mismatch_penalty = scoring_scheme['mismatch_penalty']
    gap_penalty = scoring_scheme['gap_penalty']
    
    all_paths = []

    def traceback(i, j, current_path):
        if i == 0 and j == 0:
            all_paths.append(current_path)
            return

        # Move diagonally if characters match or mismatch penalty applies
        if i > 0 and j > 0 and (scores[i, j] == scores[i - 1, j - 1] +
                                 (match_score if seq1[i - 1] == seq2[j - 1] else mismatch_penalty)):
            traceback(i - 1, j - 1, current_path + [(i - 1, j - 1)])

        # Move up (deletion)
        if i > 0 and scores[i, j] == scores[i - 1, j] + gap_penalty:
            traceback(i - 1, j, current_path + [(i - 1, j)])

        # Move left (insertion)
        if j > 0 and scores[i, j] == scores[i, j - 1] + gap_penalty:
            traceback(i, j - 1, current_path + [(i, j - 1)])

    traceback(len(seq1), len(seq2), [(len(seq1), len(seq2))])
    return all_paths
